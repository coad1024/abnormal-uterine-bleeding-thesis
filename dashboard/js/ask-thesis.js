/**
 * Ask the Thesis - Retrieval Augmented Local Answering
 * Replaces static sample responses with client-side lexical retrieval using a TF-IDF index.
 * Index file: ../thesis_index.json (generated by scripts/build_thesis_index.py)
 */

const ASK_THESIS_CONFIG = {
    indexPath: '../thesis_index.json', // relative to dashboard root when component loaded inside index.html
    maxPassages: 5,
    contributionTopK: 3,
    debug: false,
    minQueryTokens: 2,
    scoreThreshold: 0.05 // ignore extremely low similarity passages
};

let THESIS_INDEX = null; // loaded JSON
let IDF = null;          // idf mapping
let PASSAGES = [];        // documents array

// Stopword list (keep light to reduce payload) - mirrors Python builder (subset)
const STOPWORDS = new Set(["the","a","an","and","or","of","to","in","for","on","with","is","are","was","were","be","by","as","that","this","it","at","from","we","our","their","there","which","these","those","has","had","have","but","not","can","may","also","than","such","its","into","using","used","between","more","most"]);

const TOKEN_RE = /[A-Za-z]{2,}/g;

function initAskThesis() {
    const questionInput = document.getElementById('question-input');
    const askButton = document.getElementById('ask-question-btn');
    const sampleQuestions = document.querySelectorAll('.sample-question');
    const voiceInput = document.getElementById('voice-input');
    if (!questionInput || !askButton) {
        console.error('[AskThesis] Required DOM elements missing');
        return;
    }
    askButton.addEventListener('click', handleQuestion);
    questionInput.addEventListener('keypress', e => { if (e.key === 'Enter') handleQuestion(); });
    sampleQuestions.forEach(btn => btn.addEventListener('click', () => { questionInput.value = btn.textContent.trim(); handleQuestion(); }));
    if (voiceInput && 'webkitSpeechRecognition' in window) voiceInput.addEventListener('click', startVoiceInput); else if (voiceInput) voiceInput.style.display = 'none';
    loadIndex();
}

async function loadIndex() {
    const debugEl = document.getElementById('qa-debug');
    try {
        const res = await fetch(ASK_THESIS_CONFIG.indexPath + '?v=' + Date.now());
        if (!res.ok) throw new Error('HTTP ' + res.status);
        THESIS_INDEX = await res.json();
        PASSAGES = THESIS_INDEX.documents || [];
        IDF = THESIS_INDEX.idf || {};
        if (ASK_THESIS_CONFIG.debug && debugEl) {
            debugEl.classList.remove('hidden');
            debugEl.textContent = '[Index Loaded] passages=' + PASSAGES.length;
        }
    } catch (err) {
        console.error('[AskThesis] Failed to load index', err);
        if (debugEl) {
            debugEl.classList.remove('hidden');
            debugEl.textContent = 'Index load error: ' + err.message;
        }
    }
}

function tokenize(text) {
    if (!text) return [];
    return (text.match(TOKEN_RE) || [])
        .map(t => t.toLowerCase())
        .filter(t => !STOPWORDS.has(t) && t.length > 2);
}

function buildQueryVector(tokens) {
    const counts = {};
    tokens.forEach(t => counts[t] = (counts[t] || 0) + 1);
    const total = tokens.length || 1;
    const vec = {};
    Object.entries(counts).forEach(([t,c]) => {
        const tf = c / total;
        const idf = IDF[t] || 0; // unseen tokens contribute 0
        vec[t] = tf * idf;
    });
    const norm = Math.sqrt(Object.values(vec).reduce((s,v)=>s+v*v,0)) || 1;
    return {vec, norm};
}

function scorePassage(queryVec, queryNorm, passage) {
    // Precompute passage tf-idf norm each call? Python stored norm for tf only; recompute applying idf.
    let dot = 0;
    let passageNormSquared = 0;
    for (const [tok, tf] of Object.entries(passage.tf)) {
        const idf = IDF[tok] || 0;
        const w = tf * idf;
        passageNormSquared += w * w;
        if (queryVec[tok]) dot += queryVec[tok] * w;
    }
    const passageNorm = Math.sqrt(passageNormSquared) || 1;
    return dot / (queryNorm * passageNorm);
}

function handleQuestion() {
    const input = document.getElementById('question-input');
    const loader = document.getElementById('qa-loader');
    const outputWrap = document.getElementById('qa-output');
    const answerEl = document.getElementById('qa-answer');
    const citationsEl = document.getElementById('qa-citations');
    const errorEl = document.getElementById('qa-error');
    const sourcesWrap = document.getElementById('qa-sources');
    const sourceList = document.getElementById('qa-source-list');
    const debugEl = document.getElementById('qa-debug');
    const query = (input.value || '').trim();
    if (!query) return;
    if (!PASSAGES.length) {
        errorEl.innerHTML = msgNoIndex();
        errorEl.classList.remove('hidden');
        return;
    }
    // Reset UI
    loader.classList.remove('hidden');
    outputWrap.classList.add('hidden');
    errorEl.classList.add('hidden');
    sourcesWrap.classList.add('hidden');
    sourceList.innerHTML = '';
    if (citationsEl) citationsEl.classList.add('hidden');
    if (debugEl && ASK_THESIS_CONFIG.debug) debugEl.textContent = '';

    setTimeout(()=> { // allow spinner paint
        try {
            const qTokens = tokenize(query);
            if (qTokens.length < ASK_THESIS_CONFIG.minQueryTokens) {
                throw new Error('Please enter a more specific question (at least ' + ASK_THESIS_CONFIG.minQueryTokens + ' meaningful words).');
            }
            const {vec: qVec, norm: qNorm} = buildQueryVector(qTokens);
            const scored = PASSAGES.map(p => ({p, score: scorePassage(qVec, qNorm, p)}))
                .filter(r => r.score > ASK_THESIS_CONFIG.scoreThreshold)
                .sort((a,b)=> b.score - a.score)
                .slice(0, ASK_THESIS_CONFIG.maxPassages);
            if (!scored.length) throw new Error('No relevant passages found. Try rephrasing.');
            // Compose answer by extracting key sentences from top passages
            const composed = composeAnswer(query, scored.map(r=>r.p));
            answerEl.innerHTML = composed.html;
            outputWrap.classList.remove('hidden');
            // Citations
            citationsEl.innerHTML = composed.citationsHTML;
            citationsEl.classList.remove('hidden');
            // Sources list
            scored.forEach((r,i) => {
                const li = document.createElement('li');
                li.innerHTML = `<div class="font-semibold text-[11px] mb-1">[S${i+1}] ${escapeHtml(r.p.section||r.p.file)}</div>` +
                    `<div class="text-gray-700 dark:text-gray-300 leading-snug">${highlightQueryTokens(escapeHtml(r.p.text), qTokens)}</div>` +
                    `<div class="mt-1 text-[10px] opacity-70">Score: ${r.score.toFixed(3)} â€¢ ID: ${r.p.id}</div>`;
                sourceList.appendChild(li);
            });
            sourcesWrap.classList.remove('hidden');
            if (debugEl && ASK_THESIS_CONFIG.debug) debugEl.textContent = JSON.stringify({queryTokens:qTokens, top: scored.map(s=>({id:s.p.id, score:s.score}))}, null, 2);
        } catch (err) {
            errorEl.innerHTML = renderError(err.message);
            errorEl.classList.remove('hidden');
        } finally {
            loader.classList.add('hidden');
        }
    }, 50);
}

function composeAnswer(query, passages) {
    // Simple heuristic: choose 1-3 sentences from top passages that contain query tokens
    const qTokens = new Set(tokenize(query));
    const sentences = [];
    const seen = new Set();
    passages.forEach(p => {
        const rawSentences = p.text.split(/(?<=[.!?])\s+/).filter(s=>s.trim().length>20);
        for (const s of rawSentences) {
            const sTokens = tokenize(s);
            const overlap = sTokens.filter(t=> qTokens.has(t));
            if (overlap.length && !seen.has(s) && sentences.length < ASK_THESIS_CONFIG.contributionTopK) {
                seen.add(s);
                sentences.push({sentence: s, source: p});
                break; // one sentence per passage initially
            }
        }
    });
    if (!sentences.length) {
        // fallback: first sentence of first passage
        sentences.push({sentence: passages[0].text.split(/(?<=[.!?])\s+/)[0], source: passages[0]});
    }
    const htmlParts = sentences.map((obj,i) => `${escapeHtml(obj.sentence)} <sup class="text-[10px] bg-yellow-200 dark:bg-yellow-600/50 px-1 rounded">S${i+1}</sup>`);
    const html = `<p>${htmlParts.join(' ')}</p>`;
    const citationsHTML = `<div class="mt-2 text-[11px]">Sources: ${sentences.map((s,i)=>`<span class="px-1">[S${i+1}] ${escapeHtml(s.source.section||s.source.file)}</span>`).join('')}</div>`;
    return {html, citationsHTML};
}

function highlightQueryTokens(text, qTokens) {
    const set = new Set(qTokens.map(t=>t.toLowerCase()));
    return text.replace(/\b([A-Za-z]{3,})\b/g, (m,w)=> set.has(w.toLowerCase()) ? `<mark class="bg-yellow-200 dark:bg-yellow-600/50 rounded px-0.5">${m}</mark>` : m);
}

function renderError(message) {
    return `<div class="text-center"><i class="fas fa-exclamation-circle text-3xl mb-3"></i><h3 class="text-lg font-semibold mb-2">Cannot Answer</h3><p class="text-sm">${escapeHtml(message)}</p></div>`;
}

function msgNoIndex() {
    return `<div class="text-center"><h3 class="font-semibold mb-2">Index Not Built</h3><p class="text-sm">Run <code>python scripts/build_thesis_index.py</code> and reload this page.</p></div>`;
}

function escapeHtml(str) {
    return str.replace(/[&<>"] /g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',' ':' '})[c]);
}

function startVoiceInput() {
    if (!('webkitSpeechRecognition' in window)) return;
    const questionInput = document.getElementById('question-input');
    const voiceInput = document.getElementById('voice-input');
    const recognition = new webkitSpeechRecognition();
    recognition.lang = 'en-US';
    recognition.continuous = false;
    recognition.interimResults = false;
    recognition.onstart = () => { voiceInput.classList.add('text-red-500'); voiceInput.classList.remove('text-gray-400'); };
    recognition.onresult = (e) => { const transcript = e.results[0][0].transcript; questionInput.value = transcript; };
    recognition.onend = () => { voiceInput.classList.remove('text-red-500'); voiceInput.classList.add('text-gray-400'); };
    recognition.onerror = () => { voiceInput.classList.remove('text-red-500'); voiceInput.classList.add('text-gray-400'); };
    recognition.start();
}